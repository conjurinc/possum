remove old iso8601 hacked rails code

gotcha… so if ALTER fails, we want to roll it back, but if anything fails
_after_ alter succeeds, we MUST swallow it

also don't forget the follower check, the query kevin gave me.



# Testing
- add test for dynamic ttl change
- add test for dynamic ttl change

# Other stuff
- i just realized that this command `conjur variable expire` will need to be updated, correct?

The two rotators we’re on the hook for as part of the V5 release is: Postgres &
AWS Secret Access Key.  Let’s push the `expires_with` work out to allow us to
complete the key bits to ship this feature:

• Create `ConjurFacadeForRotator`
• Port Postgres rotator to Facade design
• Cukes & unit tests for Facade & PG rotator




All of these would be separate JIRA tasks.  This is a proposed priority order.  All open to debate /change:

- Write SSH keypair rotator (no tests yet, to verify design) 
    - Thoughts: this is a safety measure and kevin suggested it, but we could probably skip this.  i'm fairly confident the facade design will work already. ofc, it needs to be done anyway at, so... This is a decision where you're balancing velocity with risk.  It will probably take 1-2 days fwiw.  I guess closer to one without tests)
- Create `ConjurFacadeForRotators` (without tests)
    - This is a pre-requisite for finishing new framework code
- Update rotator framework code with new facade design (completes CONJ-5051)
- Verify postgres rotator against framework
    - Ie, the rotator I made today.  This would be manual verification only most likely, for now.
- Cukes for rotation (completes CONJ-5052)
    - These would be against the postgres rotator most likely.
- Unit tests for rotation (completes CONJ-5053)
- Cucumber tests for `ConjurFacadeForRotators`
- Unit tests for `ConjurFacadeForRotators`

Once we get here, the base "v5 rotators" should be considered done.  Everything that comes after is either rotator implementation, or performance or feature enhancements.

- Parallel execution (completes 5067)
    - Must solve the db (resource_id, version) conflict issue, either by updating the trigger code somehow, or doing locking.  Discussion with Alan / Kevin /Rafal important on this point.  Rafal in particular seems good with low-level db stuff and might have the best solution, he hasn't been involved yet in this discussion.
- Porting of existing rotators (one task for each)
- Locking and Rollback
    - Kevin's points: first 2 items on Kevin's post here: https://conjurhq.slack.com/archives/CA8AT283D/p1527276364000369
- Cron scheduling, and combo cron/ttl logic
    - Point 3 of Kevin's same post linked above, and also the followup disucssion with Ryan and Kevin.








@kgilpin, so for the AWS rotator, this:
```
- !policy
   id: aws
   body:
     - !variable region
     - !variable access_key_id
     - !variable secret_key_proxy
     - !variable
       id: secret_access_key
       annotations:
         rotation/rotator: aws/secret_key
         rotation/ttl: P1D # 1 day
```
would become (slight change from my suggestion above, after writing it out I think we should created a list of the required_variables as an annotation):
```
- !policy
   id: aws
   body:
     - !variable region
     - !variable access_key_id
     - !variable secret_key_proxy
     - !variable
       id: secret_access_key
       annotations:
         rotation/rotator: aws/secret_key
         rotation/ttl: P1D # 1 day
         rotation/required_variables: region,access_key_id,secret_access_key
         rotation/foo: bar
```
which would result in the rotator receiving a runtime call like this:

```
rotator_instance.new_values({
  region: <value of variable region>,
  access_key_id: <value of variable access_key_id>,
  secret_access_key: <value of variable secret_access_key>,
  foo: bar
})
```

@kgilpin

To summarize my conversations with Alan from yesterday, I'll need to make the following changes to the current design:

1. Remove the (currently optional) `required_variables` method from the rotator interface entirely.
2. Replace it by instead passing to the rotator a hash of all the other annotations associated with any variable that has a `rotator` annotation.
3. Such annotations may optionally be prefixed with `variable` (eg, in the case of the s3 rotator described here https://developer.conjur.net/reference/services/rotation#host_factory__s3, we would change `rotation/target/s3/access-key-id` to `rotation/variable/target/s3/access-key-id `).  This indicates that rather than passing the `value` of the annotation directly to the rotator at runtime, we instead consider `value` to be a reference to another conjur variable, and we look up the value of that variable, and pass that to the rotator at runtime.
4. Question: Do we want to enforce the `rotation/` prefix used in the s3 rotator annotations for all rotators in general?  Or should we instead use the naked `rotator` and `ttl` annotations?  In cases where those exists, we could either send *all* other annotations to the rotator according to the rules described above, or send *only* those other annotations prefixed with `rotation/`.  I'd personally lean toward forcing the `rotation/` prefix for everything rotator related, or for not using it at all

Thoughts?


- v5 supports rotation
- v5 has cukes for rotation
- v5 has unit tests for rotation
- rotation query is indexed and optimized (Rafal )



As an alternative, how about we punt the actual rotation altogether? The code
that's doing the expiration does a "puts" when it's time to rotate. So, it just
loops, looking for Secrets that need to be rotated, then updates their
expiration based on the ttl annotation.

✓ Add the `expiration` field. 
- Write a little service (or even test class) that will set the field to the
  current timestamp. 
- Then write a “watcher” which selects out the expired variables and invokes a
  dummy “rotator”

Then you’ll have the basic pieces working in a test system.

Notes:

- We can visit later whether we still need the “expiration” audit event, but
  for now we don’t; and my guess is, we won’t bring these back.
- The “expire” REST method will just set the expiration field in the DB, and
  the “rotator” will pick up the expired variables.

✓ Add the `expiration` field. 
- Write a little service (or even test class) that will set the field to the
  current timestamp. 
- Then write a “watcher” which selects out the expired variables and invokes a
  dummy “rotator”

Then you’ll have the basic pieces working in a test system.

Notes:

- We can visit later whether we still need the “expiration” audit event, but
  for now we don’t; and my guess is, we won’t bring these back.
- The “expire” REST method will just set the expiration field in the DB, and
  the “rotator” will pick up the expired variables.



Where the processes start.  We want a new rake process for our "watcher":
Invoked by conjurctl when the server starts

https://github.com/cyberark/conjur/blob/3a9fa52c844b638e4dc41341c6eb54477fd57f2c/bin/conjur-cli.rb#L74

Notes on PathBased:
https://github.com/cyberark/conjur-api-ruby/blob/v4.31.0/lib/conjur/path_based.rb

Where resourceid is defined:
https://github.com/cyberark/conjur-api-ruby/blob/4.6/lib/conjur/resource.rb#L32

Sample Dummy Rotator:
https://github.com/conjurinc/rotation/blob/master/lib/rotation/rotators/new_value.rb#L12

Using annotations to determine the correct rotator:
Also: how rotation actually gets done:

https://github.com/conjurinc/rotation/blob/master/lib/rotation/service.rb#L106
